#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VCP元思考链 - 模块批量生成脚本

使用方法:
    python3 generate_modules_template.py

功能：
    - 基于模板批量生成元逻辑模块文件
    - 支持自定义模块内容
    - 自动创建文件夹结构
    - 生成UTF-8编码的.txt文件

作者: VCPToolBox Team
版本: v1.0.0
"""

import os
import sys

# 定义模块模板
MODULE_TEMPLATE = """【{title}】
{description}

核心思想：
{core_idea}

方法/步骤：

{steps}

示例：
{example}

注意事项：
{notes}

适用场景：
{scenarios}

输出格式：
{output_format}
"""

# 定义要生成的模块
# 格式: (簇名称, 模块名称, 模块内容字典)
MODULES_TO_GENERATE = [
    # ========== 反思簇 ==========
    ("反思簇", "多角度审视", {
        "title": "多角度审视",
        "description": "从不同视角重新审视问题和结论",
        "core_idea": "避免单一视角的盲点，通过多元视角获得全面理解",
        "steps": """1. 反向思考
   - 如果结论错了会怎样？
   - 反面论证是否成立？

2. 他人视角
   - 从用户的角度看
   - 从专家的角度看
   - 从初学者的角度看

3. 时间维度
   - 短期影响
   - 中期影响
   - 长期影响

4. 领域迁移
   - 其他领域有类似情况吗？
   - 可以借鉴什么经验？

5. 极端情况
   - 最好的情况
   - 最坏的情况
   - 最可能的情况""",
        "example": """问题："是否应该使用微服务架构？"

视角1（开发者）：提高了模块化，便于团队协作
视角2（运维）：增加了部署复杂度，需要更多监控
视角3（CTO）：初期成本高，但长期有利于扩展
视角4（创业公司）：可能过度设计，单体应用更合适
视角5（大公司）：有利于团队独立迭代

综合结论：取决于团队规模、业务复杂度和发展阶段""",
        "notes": """✓ 真诚尝试理解不同观点
✓ 避免确认偏误
✓ 寻找被忽视的因素
✗ 不要流于形式
✗ 避免过度怀疑一切""",
        "scenarios": """- 决策制定
- 方案评审
- 争议性话题
- 复杂问题分析""",
        "output_format": """- 主流视角：[常见观点]
- 反向视角：[相反观点]
- 利益相关方视角：[各方看法]
- 时间维度分析：[短中长期]
- 综合结论：[平衡的看法]"""
    }),
    
    ("反思簇", "假设检验", {
        "title": "假设检验",
        "description": "系统性地验证假设的真伪",
        "core_idea": "不盲目接受假设，通过证据和逻辑进行检验",
        "steps": """1. 明确假设
   - 假设的具体陈述是什么？
   - 假设的前提是什么？

2. 预测结果
   - 如果假设为真，应该看到什么？
   - 如果假设为假，会看到什么？

3. 收集证据
   - 支持假设的证据
   - 反对假设的证据
   - 中立的证据

4. 评估证据
   - 证据的可靠性
   - 证据的相关性
   - 证据的充分性

5. 得出结论
   - 假设是否成立？
   - 置信程度如何？
   - 需要修正吗？""",
        "example": """假设："代码运行慢是因为数据库查询效率低"

预测：如果为真，应该看到：
- 数据库CPU使用率高
- 慢查询日志有记录
- Explain显示全表扫描

验证：
- 检查数据库监控 → CPU确实很高 ✓
- 查看慢查询日志 → 有多条慢查询 ✓
- 分析查询计划 → 缺少索引 ✓

结论：假设成立，原因是缺少索引""",
        "notes": """✓ 主动寻找反例
✓ 区分支持和反对证据
✓ 考虑其他可能解释
✗ 不要确认偏误
✗ 避免只看支持的证据""",
        "scenarios": """- 问题诊断
- 科学研究
- 决策验证
- 理论检验""",
        "output_format": """- 假设陈述：[明确的假设]
- 预期证据：[应该看到什么]
- 实际证据：[实际观察到什么]
- 验证结果：[成立/不成立/部分成立]
- 置信度：[高/中/低]"""
    }),
    
    # ========== 结果辩证簇 ==========
    ("结果辩证簇", "优缺点分析", {
        "title": "优缺点分析",
        "description": "全面评估方案的利弊",
        "core_idea": "客观分析优点和缺点，避免片面判断",
        "steps": """1. 列举优点
   - 核心优势
   - 独特价值
   - 竞争优势

2. 列举缺点
   - 明显不足
   - 潜在风险
   - 局限性

3. 权重评估
   - 优点的重要程度
   - 缺点的严重程度
   - 相对权重

4. 适用条件
   - 什么情况下优点突出
   - 什么情况下缺点致命
   - 边界条件

5. 综合判断
   - 优点是否大于缺点
   - 缺点是否可以接受
   - 是否有改进空间""",
        "example": """方案："使用React开发前端"

优点：
+ 组件化开发，复用性强
+ 虚拟DOM性能好
+ 生态丰富，社区活跃
+ 就业市场需求大

缺点：
- 学习曲线陡峭
- 需要配合其他库（路由、状态管理）
- 包体积相对较大
- JSX语法有争议

适用条件：
✓ 复杂交互的单页应用
✓ 团队有React经验
✗ 简单的展示型网站
✗ 团队更熟悉Vue

结论：对于复杂SPA项目且团队有经验，React是好选择""",
        "notes": """✓ 客观公正，不偏袒
✓ 既看优点也看缺点
✓ 考虑具体场景
✗ 不要过度美化
✗ 避免全盘否定""",
        "scenarios": """- 技术选型
- 方案评审
- 产品决策
- 投资评估""",
        "output_format": """- 优点：[列举优点]
- 缺点：[列举缺点]
- 权重：[重要程度评估]
- 适用条件：[什么情况下合适]
- 综合结论：[利弊权衡后的判断]"""
    }),
    
    ("结果辩证簇", "风险评估", {
        "title": "风险评估",
        "description": "识别和评估潜在风险",
        "core_idea": "预见可能的风险，提前制定应对措施",
        "steps": """1. 风险识别
   - 技术风险
   - 业务风险
   - 时间风险
   - 资源风险
   - 外部风险

2. 风险分析
   - 发生概率：高/中/低
   - 影响程度：严重/中等/轻微
   - 风险等级：概率 × 影响

3. 风险优先级
   - 高优先级：高概率 + 高影响
   - 中优先级：其他组合
   - 低优先级：低概率 + 低影响

4. 应对策略
   - 规避：不做可能产生风险的事
   - 减轻：降低概率或影响
   - 转移：保险、外包等
   - 接受：明知风险但承担

5. 监控计划
   - 风险信号
   - 检查频率
   - 触发条件""",
        "example": """项目："开发新功能上线"

风险1：技术实现困难
- 概率：中
- 影响：高
- 等级：高风险
- 策略：提前技术预研，准备备选方案

风险2：用户不接受
- 概率：中
- 影响：高
- 等级：高风险
- 策略：A/B测试，灰度发布

风险3：性能问题
- 概率：中
- 影响：中
- 等级：中风险
- 策略：压力测试，监控告警

监控：
- 每周检查进度
- 上线前全面测试
- 上线后密切监控指标""",
        "notes": """✓ 全面识别风险
✓ 量化评估
✓ 提前准备应对
✗ 不要忽视小概率大影响事件
✗ 避免过度乐观""",
        "scenarios": """- 项目管理
- 决策制定
- 投资评估
- 战略规划""",
        "output_format": """- 风险列表：[风险项]
- 风险评估：[概率×影响]
- 优先级：[排序]
- 应对策略：[具体措施]
- 监控计划：[如何监控]"""
    }),
    
    # ========== 陈词总结梳理簇 ==========
    ("陈词总结梳理簇", "结构化总结", {
        "title": "结构化总结",
        "description": "将思考结果组织成清晰的输出",
        "core_idea": "用结构化的方式呈现复杂信息，便于理解和行动",
        "steps": """1. 提炼核心要点
   - 最重要的3-5个要点
   - 用简洁的语言表达
   - 突出关键信息

2. 组织层次结构
   - 总-分结构
   - 逻辑顺序
   - 层级关系

3. 补充细节
   - 必要的说明
   - 关键的数据
   - 重要的上下文

4. 添加行动建议
   - 下一步做什么
   - 优先级如何
   - 谁负责什么

5. 检查完整性
   - 是否回答了核心问题
   - 是否有遗漏
   - 是否清晰易懂""",
        "example": """原始思考：关于提升网站性能的思考（杂乱无章）

结构化总结：

【核心结论】
网站性能问题主要在数据库查询，优化后可提升50%响应速度

【问题分析】
1. 当前状态：平均响应时间2秒，用户体验差
2. 根本原因：数据库查询慢，缺少索引
3. 影响范围：影响80%的页面

【解决方案】
1. 短期（1周）：添加缺失的索引
2. 中期（1月）：优化慢查询，引入缓存
3. 长期（3月）：数据库读写分离

【预期效果】
- 响应时间降低到0.8秒
- 数据库负载降低60%
- 用户满意度提升

【行动计划】
- 本周：DBA添加索引（优先级：高）
- 下周：开发测试效果（优先级：高）
- 下月：制定缓存方案（优先级：中）""",
        "notes": """✓ 结构清晰
✓ 重点突出
✓ 可执行性强
✗ 避免冗长啰嗦
✗ 不要遗漏关键信息""",
        "scenarios": """- 汇报工作
- 文档写作
- 会议纪要
- 项目总结""",
        "output_format": """【核心要点】
- 要点1
- 要点2
- 要点3

【详细分析】
（按需展开）

【行动建议】
- 建议1（优先级/负责人）
- 建议2（优先级/负责人）"""
    }),
    
    ("陈词总结梳理簇", "要点提炼", {
        "title": "要点提炼",
        "description": "从大量信息中提炼关键要点",
        "core_idea": "去粗取精，抓住最重要的信息",
        "steps": """1. 阅读全文
   - 完整理解内容
   - 把握主题思想
   - 识别结构框架

2. 标记重点
   - 核心论点
   - 关键数据
   - 重要结论
   - 转折观点

3. 归纳分类
   - 相似内容合并
   - 按主题分组
   - 建立层次

4. 精炼表达
   - 删除冗余
   - 简化句子
   - 保留本质

5. 检查覆盖
   - 是否涵盖主要内容
   - 是否有遗漏
   - 是否准确表达""",
        "example": """原始内容：5000字的技术报告

提炼要点：

核心发现（3条）：
1. 系统性能瓶颈在数据库层，占总响应时间70%
2. 80%的查询集中在订单表，但缺少合适索引
3. 缓存命中率仅30%，远低于行业平均60%

关键数据：
- 平均响应：2.1秒（目标<1秒）
- P95延迟：5.2秒
- 慢查询：日均3000+条

建议措施（优先级排序）：
1. [高] 订单表添加复合索引
2. [高] 优化缓存策略，提升命中率
3. [中] 引入读写分离
4. [低] 考虑分库分表

预期收益：
- 响应时间降低50%+
- 数据库负载降低40%
- 支撑用户量翻倍""",
        "notes": """✓ 抓住主干，去除枝叶
✓ 保持准确性
✓ 便于快速理解
✗ 不要丢失关键信息
✗ 避免过度简化""",
        "scenarios": """- 会议纪要
- 读书笔记
- 文献综述
- 长文总结""",
        "output_format": """【核心要点】（3-5条）
1. 要点1
2. 要点2
3. 要点3

【关键数据】（如有）
- 数据1
- 数据2

【重要结论】
- 结论1
- 结论2"""
    }),
]


def create_module_file(base_dir, cluster_name, module_name, content_dict):
    """创建单个模块文件"""
    # 构建文件路径
    cluster_path = os.path.join(base_dir, cluster_name)
    file_path = os.path.join(cluster_path, f"{module_name}.txt")
    
    # 确保目录存在
    os.makedirs(cluster_path, exist_ok=True)
    
    # 生成内容
    content = MODULE_TEMPLATE.format(**content_dict)
    
    # 写入文件
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    return file_path


def main():
    """主函数"""
    print("VCP元思考链 - 模块批量生成工具")
    print("=" * 50)
    
    # 基础目录
    base_dir = "."
    
    # 统计
    total_created = 0
    failed = []
    
    # 生成所有模块
    for cluster_name, module_name, content_dict in MODULES_TO_GENERATE:
        try:
            file_path = create_module_file(base_dir, cluster_name, module_name, content_dict)
            print(f"✓ 已创建: {cluster_name}/{module_name}.txt")
            total_created += 1
        except Exception as e:
            print(f"✗ 失败: {cluster_name}/{module_name}.txt - {e}")
            failed.append((cluster_name, module_name, str(e)))
    
    # 打印统计
    print("=" * 50)
    print(f"✓ 成功创建 {total_created} 个模块")
    if failed:
        print(f"✗ 失败 {len(failed)} 个模块:")
        for cluster, module, error in failed:
            print(f"  - {cluster}/{module}: {error}")
    
    print("\n使用说明:")
    print("1. 查看生成的模块文件")
    print("2. 根据需要修改内容")
    print("3. 参考模板添加更多模块")
    print("4. 将簇文件夹复制到 dailynote/ 目录")
    print("5. 重启VCPToolBox建立索引")
    
    return 0 if not failed else 1


if __name__ == "__main__":
    sys.exit(main())
