# 思维簇设计指南 (Thinking Cluster Design Guide)

**版本**: v1.0.0  
**目标受众**: 思维簇模块开发者、系统架构师  
**难度**: 中级到高级  

---

## 📖 目录

1. [核心概念](#1-核心概念)
2. [思维簇的本质](#2-思维簇的本质)
3. [模块结构规范](#3-模块结构规范)
4. [Prompt工程原则](#4-prompt工程原则)
5. [簇级别设计](#5-簇级别设计)
6. [标签系统](#6-标签系统)
7. [最佳实践](#7-最佳实践)
8. [反模式与陷阱](#8-反模式与陷阱)
9. [测试与验证](#9-测试与验证)
10. [高级技巧](#10-高级技巧)

---

## 1. 核心概念

### 1.1 什么是思维簇？

**思维簇 (Thinking Cluster)** 是VCP元思考系统的核心组件，本质上是：

```
思维簇 = 结构化Prompt模板库 + 向量化索引
```

**关键理解**:
- ✅ 思维簇是**Prompt指令**，不是代码逻辑
- ✅ 向量检索决定**哪些Prompt被注入**到System中
- ✅ LLM读取这些Prompt后会**自然遵循指令**执行

### 1.2 工作原理

```
用户输入: "我该辞职创业吗？"
    ↓ 向量化
    ↓
┌──────────────────────────────────────────────────┐
│ 阶段1: 前思维簇                                   │
│ ┌──────────────────────────────────────────────┐ │
│ │ 向量检索 → 最相关的2个模块                   │ │
│ │ 1. 【双轨并行架构原则】(0.87)                │ │
│ │ 2. 【社会心理语境分析】(0.83)                │ │
│ │                                              │ │
│ │ 这两个模块的**完整文本**会被注入System      │ │
│ └──────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
    ↓ 向量融合 (0.8*原始 + 0.2*结果)
    ↓
┌──────────────────────────────────────────────────┐
│ 阶段2: 逻辑推理簇                                 │
│ (使用融合后的向量检索，召回不同模块)             │
└──────────────────────────────────────────────────┘
```

### 1.3 设计哲学

**核心原则**: 
> **思维簇不是代码，而是给LLM的"思考方法论手册"**

**类比**:
- 传统编程: 硬编码每一步逻辑
- VCP思维簇: 编写"如何思考"的指南，让LLM解释执行

---

## 2. 思维簇的本质

### 2.1 三个层次的理解

#### **Level 1: 静态文本** (表层)
- 思维簇是 `.txt` 文件
- 存储在 `dailynote/<簇名>/` 目录
- 内容是结构化的文本

#### **Level 2: Prompt模板** (功能层)
- 每个文件是一个**Prompt指令集**
- 包含【思考模块】、【执行流程】等标记
- LLM读取后会理解并执行

#### **Level 3: 向量空间中的认知点** (原理层)
- 每个模块被向量化为高维空间中的一个点
- 向量相似度 = 语义相关性
- 检索 = 在认知空间中寻找最相关的"思考方式"

### 2.2 为什么不用代码实现？

**传统方式** (硬编码):
```javascript
if (problemType === '决策类') {
    // 分析利弊
    const pros = analyzePros(input);
    const cons = analyzeCons(input);
    // 评估风险
    const risks = assessRisks(input);
}
```

**VCP方式** (Prompt检索):
```markdown
【思考模块：多方利益相关者博弈分析】
【执行流程】：
1. 识别所有利益相关者（家庭、个人、合伙人...）
2. 分析每一方的诉求和底线
3. 寻找纳什均衡点
4. 评估帕累托改进空间
```

**优势**:
- ✅ 无需重新编译，修改txt即可生效
- ✅ 非技术人员可以设计思维模块
- ✅ LLM的理解能力远超简单的if-else
- ✅ 易于扩展和定制

---

## 3. 模块结构规范

### 3.1 标准模块结构

**必需字段**:
```markdown
【思考模块：<模块名称>】
【触发条件】：<何时应该召回此模块>
【核心功能】：<模块的职责和目标>
【执行流程】：
1. <第一步>
2. <第二步>
3. <第三步>
...
```

**可选字段**:
```markdown
【输入要求】：<需要什么前置信息>
【输出格式】：<产出什么结果>
【关键原则】：<不可违背的规则>
【特殊情况处理】：<边界条件和异常>
【与其他模块的协作】：<信息流转协议>
```

### 3.2 完整示例

```markdown
【思考模块：逻辑链脆弱性分析与压力测试】
【触发条件】：在"逻辑推理簇"完成推理后，作为第一层反思机制启动。
【核心功能】：扮演"红队攻击者"的角色，主动寻找推理链中的漏洞、薄弱环节和潜在反例。

【执行流程】：
1.  **逆向推理路径 (Reverse Engineering the Logic)**：
    *   回溯整个推理链，识别每一个"跳跃点"（即推理中的逻辑飞跃）。
    *   对每个跳跃点，明确追问："为什么这一步成立？有没有隐含的假设？"

2.  **关键假设提取与审查 (Critical Assumption Extraction)**：
    *   列举出支撑整个结论的所有关键假设。
    *   对每个假设进行"如果不成立会怎样"的思想实验。

3.  **反例搜索 (Counter-Example Search)**：
    *   主动构造能够反驳当前结论的情境或案例。
    *   特别关注"边界条件"和"极端情况"。

4.  **脆弱性评级与风险报告 (Vulnerability Rating & Risk Report)**：
    *   对每个识别出的漏洞进行严重性评级（致命/重要/次要）。
    *   生成一份"脆弱性报告"，传递给"执中裁决"模块。

【输出格式】：
- 脆弱性清单: [漏洞1, 漏洞2, ...]
- 风险等级: [致命/重要/次要]
- 修正建议: [如何加固推理链]

【关键原则】：
- 保持怀疑态度，不盲目信任前序结论
- 区分"理论上可能"和"现实中高概率"
- 避免过度挑剔导致分析瘫痪
```

### 3.3 命名规范

**文件命名**:
```
格式: YYYY-MM-DD-HH_MM_SS.txt
示例: 2077-04-12-16_46_27.txt
```

**模块命名**:
- ✅ 清晰描述功能: "逻辑链脆弱性分析"
- ✅ 使用动词+名词: "识别意图"、"评估风险"
- ❌ 避免模糊: "思考模块1"、"辅助功能"
- ❌ 避免过长: "基于多方利益相关者的复杂博弈论分析与纳什均衡求解"

---

## 4. Prompt工程原则

### 4.1 清晰性 (Clarity)

**原则**: 指令必须清晰、具体、可执行

**好的示例** ✅:
```markdown
【执行流程】：
1. 将问题分解为**不少于3个**子问题
2. 对每个子问题，使用MECE原则验证穷尽性
3. 检查子问题间是否存在重叠或遗漏
```

**糟糕的示例** ❌:
```markdown
【执行流程】：
1. 好好分析问题
2. 想清楚各个方面
3. 给出合理结论
```

### 4.2 结构化 (Structured)

**原则**: 使用层级结构和标记提高可读性

**技巧**:
- 使用【】标记关键字段
- 使用列表组织多步骤
- 使用缩进表示层级关系
- 使用加粗、斜体强调重点

**示例**:
```markdown
【执行流程】：
1.  **问题本质抽象化**：
    *   忽略表面领域细节（如"商业竞争"）
    *   提取核心动态关系（如"零和博弈"）
    *   转化为元问题模型

2.  **选择推理路径**：
    *   **路径A：第一性原理溯源**
        *   触发条件: 可无限分解
        *   方法: 连续追问"为什么"
    *   **路径B：跨域类比检索**
        *   触发条件: 其他领域有相似结构
        *   方法: 检索同构系统
```

### 4.3 可执行性 (Actionable)

**原则**: 指令应该是LLM可以直接执行的操作

**可执行的动词** ✅:
- 识别、提取、分析、评估、计算、比较
- 列举、分类、排序、过滤、合并
- 生成、构建、设计、优化、修正

**不可执行的动词** ❌:
- 理解、领会、体会、感受
- 综合考虑、全面把握、深刻认识

**对比**:
```markdown
❌ 深刻理解用户的潜在需求
✅ 识别用户消息中的情感词汇（焦虑、兴奋、犹豫...）
✅ 推断用户的隐含诉求（寻求安慰 vs 寻求方案）
```

### 4.4 上下文感知 (Context-Aware)

**原则**: 明确模块在思维链中的位置和角色

**需要说明**:
1. **输入**: 接收什么信息？从哪个模块来？
2. **处理**: 本模块做什么变换？
3. **输出**: 产出什么结果？传递给谁？

**示例**:
```markdown
【思考模块：动态指令重构与目标聚焦】
【触发条件】：接收"执中裁决"模块的[驳回重炼]指令后启动。
【输入要求】：
- "重审指令书"：包含问题根源和修正方向
- "历史推理链"：避免重复相同错误

【核心功能】：
将"重审指令书"转化为优化的新输入，重新启动推理链。

【输出格式】：
- "递归任务目标"：明确本次递归要解决什么问题
- "上下文保留"：保留已验证的正确部分
- "引导性提示"：例如"请从[前思维簇]重新思考"
```

---

## 5. 簇级别设计

### 5.1 五大标准簇

VCP元思考系统默认使用5阶段推理链：

| 阶段 | 簇名称 | 核心职责 | 典型模块数 |
|------|--------|----------|-----------|
| 1 | 前思维簇 | 问题理解、意图识别、语境分析 | 6-8 |
| 2 | 逻辑推理簇 | 推理、分析、问题解决 | 7-10 |
| 3 | 反思簇 | 元认知、逻辑检查、质量保证 | 5-7 |
| 4 | 结果辩证簇 | 警报定级、递归触发、成本分析 | 5-7 |
| 5 | 陈词总结梳理簇 | 输出优化、表达美化、伦理校准 | 6-8 |

### 5.2 簇的设计原则

#### **5.2.1 单一职责原则**

每个簇应专注于推理流程中的一个特定阶段：

```markdown
✅ 前思维簇 → 只负责问题分析，不做推理
✅ 逻辑推理簇 → 只负责推理，不做反思
✅ 反思簇 → 只负责检查，不做新推理
```

#### **5.2.2 信息流顺序**

簇的排列应遵循自然的思考流程：

```
问题理解 → 推理分析 → 质量检查 → 决策判定 → 输出优化
```

#### **5.2.3 模块多样性**

每个簇内应包含不同类型的模块，覆盖该阶段的多个维度：

**示例：逻辑推理簇**
```
1. 正反合辩证推理 (方法论)
2. 动态问题分解 (结构化)
3. 第一性原理溯源 (创新性)
4. 假设检验 (科学性)
5. 多方博弈分析 (系统性)
6. 交叉思辨枢纽 (高级模式)
```

### 5.3 自定义簇

**创建新簇的步骤**:

1. **创建目录**:
   ```bash
   mkdir dailynote/创意簇
   ```

2. **编写模块**:
   ```bash
   # 创建多个 .txt 文件
   touch dailynote/创意簇/2077-04-12-18_00_00.txt
   ```

3. **配置链**:
   编辑 `Plugin/RAGDiaryPlugin/meta_thinking_chains.json`:
   ```json
   {
     "chains": {
       "creative": [
         "前思维簇",
         "创意簇",
         "反思簇",
         "陈词总结梳理簇"
       ]
     }
   }
   ```

4. **向量化**:
   系统会自动检测新簇并向量化所有模块

---

## 6. 标签系统

### 6.1 可信度标签

用于标记信息的性质，影响后续处理：

| 标签 | 含义 | 使用场景 |
|------|------|----------|
| `[高置信度事实]` | 客观、可验证的信息 | 数据、研究结果、已知事实 |
| `[启发式洞察]` | 主观、经验性的判断 | 直觉、类比、价值判断 |
| `[不确定性声明]` | 存在疑问的内容 | 假设、猜测、待验证信息 |

**示例**:
```markdown
【思考模块：假设检验与归纳推理】
【执行流程】：
1. 提取核心假设并标记为`[待验证假设]`
2. 寻找支持证据并标记为`[高置信度事实]`
3. 如证据不足，标记为`[不确定性声明]`
```

### 6.2 警报级别标签

用于质量把关和递归触发：

| 标签 | 含义 | 后果 |
|------|------|------|
| `[一级警报]` | 致命问题 | 触发递归重炼 |
| `[二级警报]` | 重要缺陷 | 修补后放行 |
| `[三级警报]` | 次要瑕疵 | 直接放行 |

**示例**:
```markdown
【思考模块：执中裁决与递归熔炼】
【冲突定级】：
- **[一级警报]**：伦理审查驳回、致命逻辑漏洞
- **[二级警报]**：存在重要反例、边界模糊
- **[三级警报]**：措辞瑕疵、表达不够优雅
```

### 6.3 双轨标签

用于区分事实推理和价值判断：

| 标签 | 含义 | 路由 |
|------|------|------|
| `[事实与逻辑之轨]` | 客观分析轨道 | 逻辑推理簇 |
| `[价值与洞察之轨]` | 主观判断轨道 | 前思维簇、反思簇 |

**示例**:
```markdown
【思考模块：双轨并行架构原则】
【执行流程】：
1. 标记为`[高置信度事实]`的信息 → 路由到`[事实与逻辑之轨]`
2. 标记为`[启发式洞察]`的信息 → 路由到`[价值与洞察之轨]`
3. 两轨保持隔离，防止情感污染逻辑
4. 在"陈词总结梳理簇"最终融合
```

---

## 7. 最佳实践

### 7.1 模块粒度

**原则**: 一个模块 = 一个完整的思考方法

**过粗** ❌:
```markdown
【思考模块：全面分析】
1. 分析问题
2. 得出结论
```

**过细** ❌:
```markdown
【思考模块：提取第一个关键词】
1. 找到句子中的第一个名词
```

**恰当** ✅:
```markdown
【思考模块：动态问题分解与模式识别】
1. 将复杂问题分解为3-7个子问题
2. 使用MECE原则验证
3. 识别子问题间的依赖关系
4. 确定优先级和顺序
```

### 7.2 语言风格

**技巧**:
1. **使用祈使句**: "分析"、"提取"、"评估"
2. **避免陈述句**: "这个模块是用来..."
3. **具体量化**: "至少3个"、"不超过5个"
4. **使用专业术语**: "MECE原则"、"纳什均衡"
5. **保持一致性**: 同一簇内使用相同的格式

### 7.3 覆盖度

**完整的簇应涵盖**:
- ✅ 常规情况 (80%的输入)
- ✅ 边界情况 (15%的输入)
- ✅ 异常情况 (5%的输入)

**示例**:
```markdown
【逻辑推理簇】模块分布:
- 正反合辩证推理 (常规)
- 动态问题分解 (常规)
- 第一性原理溯源 (创新场景)
- 假设检验 (科学问题)
- 多方博弈分析 (决策问题)
- 交叉思辨枢纽 (高纠缠度场景)
```

### 7.4 测试驱动设计

**流程**:
1. **定义典型输入**: "我该辞职创业吗？"
2. **预期召回模块**: 
   - 阶段1: "社会心理语境分析"
   - 阶段2: "多方博弈分析"
   - 阶段3: "逻辑链脆弱性分析"
3. **编写模块**: 确保内容与预期场景高度相关
4. **向量化测试**: 检查是否真的被召回
5. **迭代优化**: 调整关键词和描述

---

## 8. 反模式与陷阱

### 8.1 过度抽象

**问题**: 指令太抽象，LLM无法理解

**示例** ❌:
```markdown
【思考模块：深度思考】
1. 深入分析问题本质
2. 综合各方面因素
3. 得出深刻结论
```

**改进** ✅:
```markdown
【思考模块：第一性原理溯源】
1. 连续追问"为什么"，直至无法分解
2. 识别不证自明的公理（物理定律、人性需求）
3. 基于公理自下而上重构解决方案
```

### 8.2 功能重叠

**问题**: 多个模块做同样的事

**诊断**: 如果两个模块的【核心功能】相似度>70%，考虑合并

**示例** ❌:
```markdown
模块A: 【思考模块：分析利弊】
模块B: 【思考模块：评估优缺点】
→ 这两个基本是一回事！
```

**改进** ✅:
```markdown
合并为: 【思考模块：多方利益相关者博弈分析】
- 不仅分析利弊，还考虑各方诉求
- 引入博弈论框架
- 寻求纳什均衡
```

### 8.3 循环依赖

**问题**: 模块A要求先执行B，B又要求先执行A

**示例** ❌:
```markdown
【前思维簇/意图识别】
【触发条件】：需要先完成"问题分解"

【逻辑推理簇/问题分解】
【触发条件】：需要先完成"意图识别"
```

**解决方案** ✅:
```markdown
【前思维簇/意图识别】
【触发条件】：接收原始用户输入即可启动

【逻辑推理簇/问题分解】
【触发条件】：接收"意图识别"的输出后启动
```

### 8.4 信息泄露

**问题**: 在不该交叉的地方违反了"认知防火墙"

**示例** ❌:
```markdown
【逻辑推理簇/数据分析】
【执行流程】：
1. 收集客观数据
2. 考虑用户的情感需求 ← 违反双轨原则！
3. 调整数据解读以符合用户期望 ← 事实被污染！
```

**改进** ✅:
```markdown
【逻辑推理簇/数据分析】
【执行流程】：
1. 收集客观数据
2. 进行中立的统计分析
3. 输出带`[高置信度事实]`标签的结论

（用户情感需求应在"价值与洞察之轨"单独处理）
```

---

## 9. 测试与验证

### 9.1 单元测试

**测试单个模块的质量**:

```bash
# 1. 准备测试输入
echo "我该辞职创业吗？" > test_input.txt

# 2. 手动向量化
# (使用VectorDBManager的getSingleEmbedding)

# 3. 检索目标簇
# 查看是否召回预期模块

# 4. 检查召回分数
# score > 0.7 表示相关性高
```

### 9.2 集成测试

**测试完整思维链**:

```javascript
// 在Agent配置中使用
[[VCP元思考::Group:2-1-1-1-1]]

// 发送测试输入
{
  "messages": [
    {"role": "system", "content": "{{VCPMain}}"},
    {"role": "user", "content": "我该辞职创业吗？"}
  ]
}

// 检查 VCP Info 广播
// 确认每个阶段召回的模块是否合理
```

### 9.3 质量指标

| 指标 | 目标 | 测量方法 |
|------|------|----------|
| **召回精度** | >0.75 | 平均召回分数 |
| **覆盖率** | >80% | 测试用例通过率 |
| **多样性** | >5种类型 | 每个簇的模块类型数 |
| **可读性** | A级 | Markdown Lint检查 |

### 9.4 A/B测试

**对比不同版本的模块**:

1. **准备两个版本**:
   - Version A: 原始模块
   - Version B: 优化模块

2. **相同输入测试**:
   ```
   输入: "如何学习Python？"
   
   Version A召回: "认知资源预检" (score: 0.68)
   Version B召回: "认知资源预检与工具集规划" (score: 0.82)
   ```

3. **评估LLM输出质量**:
   - 结构化程度
   - 深度和细节
   - 实用性

---

## 10. 高级技巧

### 10.1 条件分支

**在单个模块内实现逻辑分支**:

```markdown
【思考模块：跨域类比与第一性原理溯源】
【执行流程】：
1. **问题本质抽象化**：提取元问题模型

2. **选择推理路径（根据元问题特性）**：
    *   **路径A：第一性原理溯源**
        *   触发条件: 当元问题可以被不断分解时
        *   执行: 连续追问"为什么"直至公理
        *   重构: 基于公理自下而上构建方案
        
    *   **路径B：跨域类比检索**
        *   触发条件: 当元问题在其他领域有相似结构时
        *   执行: 在全局知识图谱中跨领域搜索
        *   借鉴: 分析其他领域的解决方案

3. **洞见整合与输出**
```

### 10.2 嵌套结构

**使用层级结构组织复杂逻辑**:

```markdown
【思考模块：执中裁决与递归熔炼】
【裁决流程】：
1. **报告汇总**
    - 收集"逻辑推理簇"结论
    - 收集"反思簇"审计报告
    - 提取所有`[警报]`标签

2. **冲突定级**
    - **[一级警报]**：
        * 触发条件: 伦理驳回 OR 致命漏洞
        * 后果: 触发递归重炼
        * 流程: 
            → 生成"重审指令书"
            → 调用"动态指令重构"模块
            → 重新启动推理链
    - **[二级警报]**：
        * 触发条件: 存在重要反例
        * 后果: 带批修补
        * 流程:
            → 整合反例到结论中
            → 添加"特别提醒"标记
    - **[三级警报]**：
        * 触发条件: 表达瑕疵
        * 后果: 准奏放行
        * 流程: 措辞润色后输出
```

### 10.3 动态参数

**在模块中定义可调参数**:

```markdown
【思考模块：动态问题分解与模式识别】
【配置参数】：
- MIN_SUBPROBLEMS: 3
- MAX_SUBPROBLEMS: 7
- MECE_THRESHOLD: 0.95

【执行流程】：
1. 将问题分解为 [MIN_SUBPROBLEMS, MAX_SUBPROBLEMS] 个子问题
2. 使用MECE原则验证，要求覆盖率 > MECE_THRESHOLD
3. 如不满足，重新分解或合并子问题
```

### 10.4 元编程

**编写"生成其他模块"的模块**:

```markdown
【思考模块：元认知自查与提示工程优化】
【核心功能】：审查当前推理链并生成优化建议

【执行流程】：
1. **回溯推理链**：
   - 识别每个阶段调用的模块
   - 评估模块选择是否最优

2. **生成优化建议**：
   - 如果问题类型是X，建议添加模块Y
   - 如果当前召回分数低，建议重构查询

3. **自我迭代**：
   - 输出: "建议在'逻辑推理簇'增加模块：
     【思考模块：情景规划与未来推演】
     【触发条件】：处理战略决策问题时
     【核心功能】：构建多种可能的未来情景..."
```

### 10.5 外部知识集成

**在模块中引用外部知识库**:

```markdown
【思考模块：科学假设检验】
【执行流程】：
1. 提取核心假设
2. 查询外部数据库:
   - 学术论文: arXiv, PubMed
   - 统计数据: World Bank, UN Data
   - 案例研究: Harvard Business Review
3. 标记证据可信度:
   - `[高置信度事实]`: 同行评审论文
   - `[中等置信度]`: 行业报告
   - `[不确定性]`: 单一案例或观点
```

---

## 附录 A: 模块模板

### A.1 基础模板

```markdown
【思考模块：<模块名称>】
【触发条件】：<何时召回此模块>
【核心功能】：<模块的核心职责，1-2句话>
【执行流程】：
1.  **<步骤1名称>**：
    *   <具体操作>
    *   <预期结果>

2.  **<步骤2名称>**：
    *   <具体操作>
    *   <预期结果>

3.  **<步骤3名称>**：
    *   <具体操作>
    *   <预期结果>

【输出格式】：
- <输出项1>: [描述]
- <输出项2>: [描述]

【关键原则】：
- <不可违背的规则1>
- <不可违背的规则2>
```

### A.2 高级模板

```markdown
【思考模块：<模块名称>】
【所属簇】：<簇名称>
【触发条件】：<详细的触发规则>
【核心功能】：<详细描述模块职责>

【输入要求】：
- 必需输入: <必须有的前置信息>
- 可选输入: <可有可无的辅助信息>

【执行流程】：
1.  **<阶段1>**：
    *   **子步骤1.1**: <详细操作>
    *   **子步骤1.2**: <详细操作>

2.  **<阶段2>**（条件分支）：
    *   **如果条件A成立**：
        *   执行方案A
    *   **否则**：
        *   执行方案B

3.  **<阶段3>**：
    *   <汇总和输出>

【输出格式】：
- 主要输出: <格式和内容>
- 元数据: <标签、置信度等>

【关键原则】：
- <不可违背的规则>

【与其他模块的协作】：
- 接收来自: <上游模块列表>
- 传递给: <下游模块列表>
- 协作协议: <信息格式和传递规则>

【特殊情况处理】：
- 边界条件: <如何处理>
- 异常情况: <如何处理>
- 降级方案: <失败时的备选方案>

【质量保证】：
- 自检清单: <执行后检查项>
- 预期输出质量: <评判标准>
```

---

## 附录 B: 快速参考

### B.1 命令速查

```bash
# 创建新簇
mkdir dailynote/<新簇名>

# 创建新模块
touch dailynote/<簇名>/$(date +%Y-%m-%d-%H_%M_%S).txt

# 查看当前簇列表
ls dailynote/

# 查看某簇的模块数量
ls dailynote/<簇名>/ | wc -l

# 搜索包含特定关键词的模块
grep -r "关键词" dailynote/
```

### B.2 配置文件位置

```
Plugin/RAGDiaryPlugin/
├── meta_thinking_chains.json      # 思维链配置
├── semantic_groups.json           # 语义组配置
└── SemanticGroupManager.js        # 语义组管理器

dailynote/
├── 前思维簇/
├── 逻辑推理簇/
├── 反思簇/
├── 结果辩证簇/
└── 陈词总结梳理簇/
```

### B.3 常用标签

```markdown
# 可信度标签
[高置信度事实]
[启发式洞察]
[不确定性声明]

# 警报标签
[一级警报]
[二级警报]
[三级警报]

# 双轨标签
[事实与逻辑之轨]
[价值与洞察之轨]

# 动作标签
[驳回重炼]
[带批修补]
[准奏放行]
```

---

## 结语

思维簇设计是一门**Prompt工程的艺术**。它要求你：

1. ✅ 理解LLM的能力边界
2. ✅ 熟悉认知科学和方法论
3. ✅ 掌握结构化写作技巧
4. ✅ 具备系统设计思维

**记住**:
> 好的思维簇不是写代码，而是**编写给LLM的"思考说明书"**。

**持续改进**:
- 📊 收集实际使用数据
- 🧪 A/B测试不同版本
- 📚 学习其他领域的方法论
- 🔄 迭代优化模块内容

**祝你创造出卓越的思维簇！** 🚀

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-14  
**作者**: VCP开发团队  
**反馈**: 欢迎在GitHub Issues提出建议
